import { D as I, N as S, a as T, c as x, d as A, p as F, r as L } from "./continuous-ybARbRnI.mjs";
function d(n, h, u, l) {
  const r = h.formatToParts(n);
  u && r.unshift({ type: "prefix", value: u }), l && r.push({ type: "suffix", value: l });
  const f = [], a = [], p = [], c = [], o = {}, s = (t) => `${t}:${o[t] = (o[t] ?? -1) + 1}`;
  let y = "", g = !1, v = !1;
  for (const t of r) {
    y += t.value;
    const e = t.type === "minusSign" || t.type === "plusSign" ? "sign" : t.type;
    e === "integer" ? (g = !0, a.push(...t.value.split("").map((i) => ({ type: e, value: parseInt(i) })))) : e === "group" ? a.push({ type: e, value: t.value }) : e === "decimal" ? (v = !0, p.push({ type: e, value: t.value, key: s(e) })) : e === "fraction" ? p.push(...t.value.split("").map((i) => ({
      type: e,
      value: parseInt(i),
      key: s(e),
      pos: -1 - o[e]
    }))) : (g || v ? c : f).push({
      type: e,
      value: t.value,
      key: s(e)
    });
  }
  const m = [];
  for (let t = a.length - 1; t >= 0; t--) {
    const e = a[t];
    m.unshift(e.type === "integer" ? {
      ...e,
      key: s(e.type),
      pos: o[e.type]
    } : {
      ...e,
      key: s(e.type)
    });
  }
  return {
    pre: f,
    integer: m,
    fraction: p,
    post: c,
    valueAsString: y,
    value: typeof n == "string" ? parseFloat(n) : n
  };
}
export {
  I as Digit,
  S as NumberFlowLite,
  T as canAnimate,
  x as continuous,
  A as define,
  d as formatToData,
  F as prefersReducedMotion,
  L as renderInnerHTML
};
